
\section{\label{sec:Introduction}Introduction}

Today, smartphones and tablets are used primarily to run interactive
foreground applications, such as games and web browsers.  As a result,
current mobile devices are optimized for a use case where applications
are used intermittently during the day, in sessions that last for
several minutes.  For example, during her break Alice picks up
her phone, checks the weather, reads the latest news and plays a
game for a few minutes, and then puts it away to go back to work.  To
maximize battery life, current mobile devices are designed to go
into sleep state for most of the day when they are not supporting such
interactive usage.

Unfortunately, most mobile platforms are a poor match for a growing
class of mobile applications that perform continuous background
sensing.  Examples range from context-aware applications~\cite{baldauf2007survey,hong2009context}, such as
medical applications~\cite{hameed2003application,preuveneers2008mobile,tsai2007usability} that improve our
well-being or even save lives using activity recognition (e.g., fall
detection), to applications that use participatory sensing to get a
better understanding of the physical world, such as noise pollution
monitoring~\cite{maisonneuve2009citizen,maisonneuve2009noisetube} or traffic prediction~\cite{hull2006cartel}.  While the processing demands of
these applications are modest most of the time, they require periodic
collection of sensor readings, which prevents the device from going to
sleep for extended periods of time.  As a result, applications that
perform continuous sensing may cause the device's battery to drain
within several hours.

To improve support for continuous sensing applications the research
community has proposed the use of fully programmable heterogeneous
architectures~\cite{reflex,littlerock,turducken}.  In these
approaches, developers partition their applications to offload the
initial stages of the application to a low-power processor
(or a hierarchy of processors).  When the code running on the low
power processor detects the occurrence of an event of interest, it
proceeds to wake up the phone and passes control to the rest of the
application.  While the ability to run custom code on the low-power
hardware provides great flexibility, the significant complexity
inherent in this approach has so far prevented its adoption in
commercial devices.  Instead, smartphone manufacturers, realizing the
potential of sensing applications, have recently incorporated
low-power processors into their architectures, but have limited
application developers to APIs that provide fixed functionality, by
either batching sensor readings or recognizing a small number of
predefined activities that can be used as wake-up
conditions~\cite{androidMotionSensors,coreMotion,motox}.

In this paper we argue that these APIs are insufficient for supporting
a rich and flexible set of continuous sensing applications.
Batching is inefficient for applications that depend on infrequent
events and is not appropriate for applications that require crisp
response time.  An activity recognition API provides little
flexibility with no support for applications interested in events that
are not covered by the set of predefined activities.  

Instead, we argue that the sensing API should expose access to
pre-processing algorithms on a low-power processor.  Data pre-processing includes data 
cleaning, normalization, transformation, feature extraction and 
selection, etc~\cite{kotsiantis2006data} \hl{Q: Previous sentence was copied word 
for word from the paper's abstract. Is that ok? Need to format differently?}.  We propose an
approach that enables programmers to create custom wake-up conditions
by choosing among a set of predefined pre-processing algorithms, implemented 
on the low-power processor, and tuning
their parameters.  By providing developers with access to commonly used
pre-processing algorithms (e.g., noise reduction, feature extraction), 
as opposed to higher-level activity detectors, this approach provide a 
better balance between flexibility and ease of
deployment.  This access allows developers to create a broad set of
simple event classifiers that can be used to detect a wide range of
activities.  Simultaneously, they are significantly easier to program
compared to fully programmable offloading.  Moreover, since the
pre-processing algorithms are pre-specified, their implementations can be optimized (by
the device manufacturer) for each low-power processor, improving
application portability between devices.  Furthermore, it is possible
to combine the pre-processing and wake-up operations when multiple applications
register interest in the same set of events.  While simple classifiers could
be programmed directly by individual applications, it is easy to
imagine activity recognition libraries that take advantage of the
functionality of our approach, to provide detection algorithms
for a large number of activities.

The rest of this paper is organized as follows.
Section~\ref{sec:background} discusses existing approaches to
continuous sensing and their limitations.  Section~\ref{sec:conjecture}
proposes a conjecture, describes our new approach for continuous sensing and identifies
some of its advantages and challenges.  Section~\ref{sec:validation} highlights the
limitations of existing sensing approaches and provides
some evidence that supports the proposed conjecture.  Finally, Section~\ref{sec:conclusion} 
conclude the paper.

